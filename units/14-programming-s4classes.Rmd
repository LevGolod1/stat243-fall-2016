---
title: "Programming with S4 Classes"
author: "Gaston Sanchez"
date: "October 9, 2016"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, error = TRUE)
```

## S4 Classes

Another type of OOP system in R is the so-called S4 classes. This system is
more formal and rigorous than S3 classes.

To define a new class, you use the `setClass()` function. For example, here's
how to define a class `"coin"`:

```{r}
# class "coin"
setClass(
  Class = "coin",
  representation = representation(
    sides = "character",
    prob = "numeric"
  )
)
```

The argument `Class` is used to specify the name of the class. The argument
`representation` allows you specify the attributes of the objects. Compared
to S3 classes, S4 classes allows you to be more explicit about the exact
type of objects fot the attributes. In the `coin` example, the `sides` of
the coin are set to a character vector; likewise the `prob` (probabilities)
of each side are set to a numeric vector.

You initialize a `"coin"` object with `new()`
```{r}
coin1 <- new(Class = "coin", 
             sides = c("heads", "tails"), 
             prob = c(0.5, 0.5))
coin1
```

Another coin:
```{r}
quarter1 <- new(Class = "coin", 
                sides = c("washington", "fort"), 
                prob = c(0.5, 0.5))
quarter1
```

You access the attributes with the slot operator `@`:
```{r}
coin1@sides
coin1@prob
```


### Prototype

When defining a class, often it's good to include a `prototype`, that is, a
_default_ instance for an object:
```{r}
# class "coin"
setClass(
  Class = "coin",
  representation = representation(
    sides = "character",
    prob = "numeric"
  ),
  prototype = prototype(
    sides = c('heads', 'tails'),
    prob = c(0.5, 0.5)
  )
)
```
Notice that, by default, creating a new `"coin"` will have `sides` attributes
heads and tails, and probabilities `prob` 0.5 (i.e. a fair coin).

Let's re-initialize `coin1` with the default `prototype`:
```{r}
coin1 <- new(Class = "coin")
coin1
```

To inspect the attributes of an object of class S4, you can use `slotNames()` 
and `getSlots()`
```{r}
slotNames("coin")
getSlots("coin")
```

Like the `print` method with S3 classes, you can define a `print` method for
S4 classes. To do so, use the function `setMethod()`. When declaring a specific 
`"print"` method you use the argument `signature = "coin"` to indicate that
there will be a new `print()` method for objects `"coin"`.
```{r}
setMethod(
  "print",
  signature = "coin", 
  function(x, ...) {
    cat('object "coin"\n')
    cat("sides: ")
    print(x@sides)
    cat("prob: ")
    print(x@prob)
  }
)
```

Now, when you `print()` an object of class `"coin"`, the specified method
is applied to `"coin"`:
```{r}
print(coin1)
```

To see the defined methods on a given class, use `showMethods()`:
```{r}
showMethods(class = "coin")
```


## Constructor functions

The way we have defined the class `"coin"` is not entirely correct.
```{r}
# weird coin
weird <- new("coin", 
             sides = c('tic', 'tac', 'toe'),
             prob = c(1))
```

Even though we are requiring `sides` to be `character`, and `prob` to be 
`numeric`, we didn't specified anything else about the length, or their 
possible content.

To have a better mechanism, S4 provides a `validity` argument:
```{r}
# class "coin"
setClass(
  Class = "coin",
  representation = representation(
    sides = "character",
    prob = "numeric"
  ),
  validity = function(object) {
    if (length(object@sides) != 2) {
      stop("'sides' must be of length 2")
    }
    if (length(object@prob) != 2) {
      stop("'prob' must be of length 2")
    }
  },
  prototype = prototype(
    sides = c('heads', 'tails'),
    prob = c(0.5, 0.5)
  )
)
```

Now, it is less likely to have weird coins:
```{r}
weird <- new("coin", 
             sides = c('tic', 'tac', 'toe'),
             prob = c(1))
```


Initializing an object with `new()` is not very user friendly. Instead, you
typically create a user-intended __public constructor__ function:
```{r}
coin <- function(sides, prob) {
  new(Class = "coin",
      sides = sides,
      prob = prob)
}
```

Using the public constructor function is like 
```{r}
loaded <- coin(sides = c('h', 't'), prob = c(0.3, 0.7))
```


## Generic Methods

In addition to existing methods in R, you can also declare a new generic method.
Use `setGeneric()`:
```{r}
setGeneric(
  "flip",
  function(object, ...) standardGeneric("flip")
)
```

Once the method has been declared, you use `setMethod()` for defining specific
methods:
```{r}
setMethod(
  "flip", 
  signature = "coin",
  function(object, times = 1) {
    sample(object@sides, size = times, replace = TRUE, prob = object@prob)
  }
)
```

Let's try `flip()`
```{r}
flip(coin1, times = 5)
```


## A `"toss"` object

Like we did with S3 classes, we are going to create a `"toss"` object using
S4 classes. This object will have four attributes:

- the vector of tosses
- the `sides` of the coin
- the `prob` of each side
- the `total` number of tosses
- the number of `heads`
- the number of `tails`

```{r}
# class "toss"
setClass(
  Class = "toss",
  representation = representation(
    tosses = "character",
    sides = "character",
    prob = "numeric",
    total = "integer",
    heads = "integer",
    tails = "integer"
  ),
  validity = function(object) {
    if (length(object@sides) != 2) {
      stop("'sides' must be of length 2")
    }
    if (length(object@prob) != 2) {
      stop("'prob' must be of length 2")
    }
  },
  prototype = prototype(
    sides = c('heads', 'tails'),
    prob = c(0.5, 0.5)
  )
)
```


We want a constructor function `toss()`:
```{r}
toss <- function(coin, times) {
  tosses = flip(coin, times = times)
  new(Class = "tosses",
      tosses = tosses,
      coin@sides = sides,
      coin@prob = prob,
      total = length(tosses),
      heads = sum(tosses == "heads"),
      tails = sum(tosses == "tails"))
}
```


